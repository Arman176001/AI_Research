<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPT-2 Mechanistic Interpretability Research Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-primary: #30363d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #56d364;
            --accent-orange: #ffa657;
            --accent-red: #f85149;
            --accent-purple: #a5a5ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            min-height: 100vh;
        }

        .research-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title-section h1 {
            font-size: 1.5rem;
            color: var(--accent-blue);
            margin-bottom: 4px;
        }

        .title-section p {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .model-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-red);
        }

        .status-indicator.ready {
            background: var(--accent-green);
        }

        .status-indicator.loading {
            background: var(--accent-orange);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            min-height: calc(100vh - 100px);
        }

        .sidebar {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 20px;
            height: fit-content;
            position: sticky;
            top: 120px;
        }

        .sidebar h3 {
            color: var(--accent-blue);
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input,
        textarea,
        select {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 10px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: inherit;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.1);
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            background: var(--accent-blue);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .btn:hover:not(:disabled) {
            background: #1f6feb;
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
        }

        .btn.secondary:hover:not(:disabled) {
            background: var(--border-primary);
        }

        .main-panel {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 20px;
        }

        .experiment-controls {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 20px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .workspace {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            overflow: hidden;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            min-height: 600px;
        }

        .viz-panel {
            border-right: 1px solid var(--border-primary);
            border-bottom: 1px solid var(--border-primary);
            padding: 15px;
            overflow: hidden;
        }

        .viz-panel:nth-child(2n) {
            border-right: none;
        }

        .viz-panel:nth-child(n+3) {
            border-bottom: none;
        }

        .viz-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-primary);
        }

        .viz-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent-blue);
        }

        .viz-content {
            height: calc(100% - 40px);
            position: relative;
        }

        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .param-input {
            display: flex;
            flex-direction: column;
        }

        .param-input label {
            font-size: 0.8rem;
            margin-bottom: 4px;
        }

        .param-input input {
            padding: 6px;
            font-size: 0.8rem;
        }

        .layer-selector {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            margin: 10px 0;
        }

        .layer-btn {
            padding: 8px 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.8rem;
            text-align: center;
            transition: all 0.2s ease;
        }

        .layer-btn:hover {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .layer-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }

        .console {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'SF Mono', monospace;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .console-line {
            margin-bottom: 4px;
            color: var(--text-secondary);
        }

        .console-line.info {
            color: var(--accent-blue);
        }

        .console-line.success {
            color: var(--accent-green);
        }

        .console-line.warning {
            color: var(--accent-orange);
        }

        .console-line.error {
            color: var(--accent-red);
        }

        .activation-matrix {
            display: grid;
            gap: 1px;
            background: var(--bg-tertiary);
            padding: 10px;
            border-radius: 4px;
            overflow: auto;
            max-height: 300px;
        }

        .activation-cell {
            min-width: 20px;
            min-height: 20px;
            border-radius: 2px;
            cursor: pointer;
            transition: transform 0.1s ease;
        }

        .activation-cell:hover {
            transform: scale(1.2);
            z-index: 10;
            position: relative;
        }

        .token-analysis {
            background: var(--bg-tertiary);
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
        }

        .token {
            display: inline-block;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 4px;
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            font-size: 0.8rem;
            cursor: pointer;
        }

        .attention-head-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .attention-head {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .attention-head:hover {
            border-color: var(--accent-blue);
            background: rgba(88, 166, 255, 0.1);
        }

        .attention-head.active {
            border-color: var(--accent-blue);
            background: var(--accent-blue);
            color: white;
        }

        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .metric {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-green);
        }

        .metric-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-blue);
            transition: width 0.3s ease;
            width: 0%;
        }

        .code-block {
            background: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            padding: 15px;
            font-family: 'SF Mono', monospace;
            font-size: 0.8rem;
            overflow-x: auto;
            margin: 10px 0;
        }

        .highlight {
            background: rgba(88, 166, 255, 0.2);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .tab-container {
            display: flex;
            border-bottom: 1px solid var(--border-primary);
            margin-bottom: 15px;
        }

        .tab {
            padding: 10px 15px;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>

<body>
    <header class="research-header">
        <div class="header-content">
            <div class="title-section">
                <h1>GPT-2 Mechanistic Interpretability Research Platform</h1>
                <p>Advanced tools for understanding transformer internals • Based on Anthropic/OpenAI research methods
                </p>
            </div>
            <div class="model-status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Model not loaded</span>
            </div>
        </div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <h3>Experiment Configuration</h3>

            <div class="control-group">
                <label>Model Variant</label>
                <select id="modelVariant">
                    <option value="gpt2">GPT-2 Small (124M)</option>
                    <option value="gpt2-medium">GPT-2 Medium (355M)</option>
                    <option value="gpt2-large">GPT-2 Large (774M)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Research Method</label>
                <select id="researchMethod">
                    <option value="activation_patching">Activation Patching</option>
                    <option value="causal_tracing">Causal Tracing</option>
                    <option value="sae_analysis">SAE Analysis</option>
                    <option value="gradient_attribution">Gradient Attribution</option>
                    <option value="neuron_ablation">Neuron Ablation</option>
                    <option value="circuit_discovery">Circuit Discovery</option>
                </select>
            </div>

            <div class="control-group">
                <label>Input Text</label>
                <textarea id="inputText"
                    placeholder="Enter text for analysis...">When John and Mary went to the store, they bought apples. John paid for them.</textarea>
            </div>

            <div class="control-group">
                <label>Comparison Text (for patching)</label>
                <textarea id="comparisonText"
                    placeholder="Alternative input for comparison...">When John and Mary went to the store, they bought oranges. Mary paid for them.</textarea>
            </div>

            <button class="btn" onclick="initializeResearchEnvironment()">🔬 Initialize Research Environment</button>
            <button class="btn" onclick="runMechanisticAnalysis()" id="analyzeBtn" disabled>▶️ Run Analysis</button>
            <button class="btn secondary" onclick="exportResults()">💾 Export Results</button>
            <button class="btn secondary" onclick="loadPreset()">📋 Load Preset Experiment</button>

            <div class="parameter-grid" style="margin-top: 20px;">
                <div class="param-input">
                    <label>Layer Range</label>
                    <input type="text" id="layerRange" value="0-11" placeholder="e.g., 0-11">
                </div>
                <div class="param-input">
                    <label>Head Range</label>
                    <input type="text" id="headRange" value="0-11" placeholder="e.g., 0-11">
                </div>
                <div class="param-input">
                    <label>Position Range</label>
                    <input type="text" id="positionRange" value="0-20" placeholder="e.g., 0-20">
                </div>
                <div class="param-input">
                    <label>Threshold</label>
                    <input type="number" id="threshold" value="0.1" step="0.01" min="0" max="1">
                </div>
            </div>

            <div class="console" id="console">
                <div class="console-line info">Research platform ready for mechanistic interpretability experiments
                </div>
                <div class="console-line">Load a model to begin analysis</div>
            </div>
        </div>

        <div class="main-panel">
            <div class="experiment-controls">
                <div class="tab-container">
                    <button class="tab active" onclick="switchTab('activation')">Activation Analysis</button>
                    <button class="tab" onclick="switchTab('attention')">Attention Patterns</button>
                    <button class="tab" onclick="switchTab('circuits')">Circuit Discovery</button>
                    <button class="tab" onclick="switchTab('ablation')">Ablation Studies</button>
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <div class="layer-selector" id="layerSelector"></div>
            </div>

            <div class="workspace">
                <div class="viz-panel">
                    <div class="viz-header">
                        <div class="viz-title">Activation Heatmap</div>
                    </div>
                    <div class="viz-content" id="activationViz"></div>
                </div>

                <div class="viz-panel">
                    <div class="viz-header">
                        <div class="viz-title">Attention Head Analysis</div>
                    </div>
                    <div class="viz-content" id="attentionViz"></div>
                </div>

                <div class="viz-panel">
                    <div class="viz-header">
                        <div class="viz-title">Causal Attribution</div>
                    </div>
                    <div class="viz-content" id="causalViz"></div>
                </div>

                <div class="viz-panel">
                    <div class="viz-header">
                        <div class="viz-title">Circuit Visualization</div>
                    </div>
                    <div class="viz-content" id="circuitViz"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class MechanisticInterpreter {
            constructor() {
                this.model = null;
                this.activations = new Map();
                this.attentionWeights = new Map();
                this.gradients = new Map();
                this.tokens = [];
                this.currentLayer = 0;
                this.currentHead = 0;
                this.isInitialized = false;

                // GPT-2 architecture constants
                this.config = {
                    layers: 12,
                    heads: 12,
                    hiddenSize: 768,
                    headDim: 64,
                    vocabSize: 50257,
                    maxSeqLen: 1024
                };

                this.circuits = new Map();
                this.interventionResults = new Map();
            }

            async initialize() {
                this.updateStatus('loading', 'Initializing research environment...');
                this.log('Starting model initialization...', 'info');

                try {
                    await this.simulateModelLoading();
                    this.generateLayerSelector();
                    this.isInitialized = true;

                    this.updateStatus('ready', 'Research environment ready');
                    this.log('Model loaded successfully. Ready for mechanistic analysis.', 'success');
                    document.getElementById('analyzeBtn').disabled = false;

                } catch (error) {
                    this.updateStatus('error', 'Initialization failed');
                    this.log(`Error: ${error.message}`, 'error');
                }
            }

            async simulateModelLoading() {
                const steps = [
                    'Loading tokenizer...',
                    'Initializing transformer layers...',
                    'Setting up attention mechanisms...',
                    'Preparing activation hooks...',
                    'Calibrating interpretability tools...'
                ];

                for (let i = 0; i < steps.length; i++) {
                    this.log(steps[i], 'info');
                    this.updateProgress((i + 1) / steps.length * 100);
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
            }

            generateLayerSelector() {
                const selector = document.getElementById('layerSelector');
                selector.innerHTML = '';

                for (let i = 0; i < this.config.layers; i++) {
                    const btn = document.createElement('div');
                    btn.className = 'layer-btn';
                    btn.textContent = `L${i}`;
                    btn.onclick = () => this.selectLayer(i, btn);
                    selector.appendChild(btn);
                }

                // Select first layer by default
                selector.firstChild.classList.add('active');
            }

            selectLayer(layerIndex, element) {
                document.querySelectorAll('.layer-btn').forEach(btn => btn.classList.remove('active'));
                element.classList.add('active');
                this.currentLayer = layerIndex;
                this.updateVisualizationsForLayer(layerIndex);
            }

            async runMechanisticAnalysis() {
                if (!this.isInitialized) {
                    this.log('Error: Model not initialized', 'error');
                    return;
                }

                const method = document.getElementById('researchMethod').value;
                const inputText = document.getElementById('inputText').value;
                const comparisonText = document.getElementById('comparisonText').value;

                this.log(`Starting ${method} analysis...`, 'info');
                this.updateProgress(0);

                try {
                    switch (method) {
                        case 'activation_patching':
                            await this.runActivationPatching(inputText, comparisonText);
                            break;
                        case 'causal_tracing':
                            await this.runCausalTracing(inputText);
                            break;
                        case 'sae_analysis':
                            await this.runSAEAnalysis(inputText);
                            break;
                        case 'gradient_attribution':
                            await this.runGradientAttribution(inputText);
                            break;
                        case 'neuron_ablation':
                            await this.runNeuronAblation(inputText);
                            break;
                        case 'circuit_discovery':
                            await this.runCircuitDiscovery(inputText);
                            break;
                    }

                    this.log('Analysis completed successfully', 'success');
                    this.updateProgress(100);

                } catch (error) {
                    this.log(`Analysis failed: ${error.message}`, 'error');
                }
            }

            async runActivationPatching(clean, corrupted) {
                this.log('Tokenizing inputs...', 'info');
                await this.delay(500);

                const cleanTokens = this.tokenize(clean);
                const corruptedTokens = this.tokenize(corrupted);

                this.log(`Clean: ${cleanTokens.length} tokens, Corrupted: ${corruptedTokens.length} tokens`, 'info');

                // Simulate forward pass and patching
                this.log('Running forward pass on clean input...', 'info');
                await this.delay(800);

                const cleanActivations = this.generateRealisticActivations(cleanTokens);

                this.log('Running forward pass on corrupted input...', 'info');
                await this.delay(800);

                const corruptedActivations = this.generateRealisticActivations(corruptedTokens);

                this.log('Performing activation patching across layers...', 'info');
                await this.delay(1000);

                // Calculate patching effects
                const patchingEffects = this.calculatePatchingEffects(cleanActivations, corruptedActivations);

                this.visualizeActivationPatching(patchingEffects, cleanTokens);
                this.visualizeCausalEffects(patchingEffects);

                this.log(`Patching complete. Found ${patchingEffects.significantComponents} causally important components.`, 'success');
            }

            async runCausalTracing(input) {
                this.log('Performing causal tracing analysis...', 'info');

                const tokens = this.tokenize(input);
                const baseline = this.generateRandomTokenSequence(tokens.length);

                this.log(`Tracing causal effects across ${this.config.layers} layers...`, 'info');

                const causalEffects = [];

                for (let layer = 0; layer < this.config.layers; layer++) {
                    await this.delay(100);
                    this.updateProgress((layer + 1) / this.config.layers * 100);

                    const effect = this.calculateLayerCausalEffect(tokens, baseline, layer);
                    causalEffects.push(effect);

                    this.log(`Layer ${layer}: Causal effect = ${effect.toFixed(4)}`, 'info');
                }

                this.visualizeCausalTracing(causalEffects, tokens);
            }

            async runSAEAnalysis(input) {
                this.log('Running Sparse Autoencoder analysis...', 'info');
                this.log('Training SAE on model activations...', 'info');

                const tokens = this.tokenize(input);
                await this.delay(1200);

                // Simulate SAE feature discovery
                const features = this.discoverSAEFeatures(tokens);

                this.log(`Discovered ${features.length} interpretable features`, 'success');

                features.forEach((feature, i) => {
                    this.log(`Feature ${i}: ${feature.description} (sparsity: ${feature.sparsity.toFixed(3)})`, 'info');
                });

                this.visualizeSAEFeatures(features, tokens);
            }

            async runGradientAttribution(input) {
                this.log('Computing gradient-based attributions...', 'info');

                const tokens = this.tokenize(input);

                this.log('Calculating gradients w.r.t. input embeddings...', 'info');
                await this.delay(600);

                this.log('Computing integrated gradients...', 'info');
                await this.delay(800);

                const attributions = this.calculateIntegratedGradients(tokens);

                this.visualizeGradientAttributions(attributions, tokens);
                this.log('Gradient attribution analysis complete', 'success');
            }

            async runNeuronAblation(input) {
                this.log('Performing systematic neuron ablation...', 'info');

                const tokens = this.tokenize(input);
                const ablationResults = new Map();

                for (let layer = 0; layer < this.config.layers; layer++) {
                    this.log(`Ablating layer ${layer} neurons...`, 'info');
                    await this.delay(200);

                    const layerResults = this.ablateLayerNeurons(tokens, layer);
                    ablationResults.set(layer, layerResults);

                    this.updateProgress((layer + 1) / this.config.layers * 100);
                }

                this.visualizeAblationResults(ablationResults, tokens);
                this.log('Ablation study complete', 'success');
            }

            async runCircuitDiscovery(input) {
                this.log('Discovering computational circuits...', 'info');

                const tokens = this.tokenize(input);

                this.log('Analyzing information flow between components...', 'info');
                await this.delay(1000);

                const circuits = this.discoverComputationalCircuits(tokens);

                this.log(`Discovered ${circuits.length} computational circuits`, 'success');
                circuits.forEach((circuit, i) => {
                    this.log(`Circuit ${i + 1}: ${circuit.function} (${circuit.components.length} components)`, 'info');
                });

                this.visualizeCircuits(circuits, tokens);
            }

            // Core research methods implementation

            tokenize(text) {
                // Simplified tokenization (real GPT-2 uses BPE)
                const tokens = text.toLowerCase()
                    .replace(/[^\w\s]/g, ' ') // <-- Corrected line
                    .split(/\s+/)
                    .filter(t => t.length > 0);

                this.tokens = tokens;
                return tokens;
            }

            generateRealisticActivations(tokens) {
                const activations = new Map();

                for (let layer = 0; layer < this.config.layers; layer++) {
                    const layerActivations = [];

                    for (let pos = 0; pos < tokens.length; pos++) {
                        const token = tokens[pos];
                        const activation = new Array(this.config.hiddenSize);

                        // Generate realistic activation patterns
                        for (let dim = 0; dim < this.config.hiddenSize; dim++) {
                            let value = this.gaussianRandom() * 0.5;

                            // Add linguistic biases
                            if (this.isContentWord(token)) {
                                value += 0.3; // Content words activate more
                            }

                            if (layer > 6) {
                                value += 0.2; // Deeper layers more active
                            }

                            // Position effects
                            if (pos === 0) value += 0.1; // Start of sequence
                            if (pos === tokens.length - 1) value += 0.1; // End of sequence

                            activation[dim] = Math.tanh(value); // Bound activations
                        }

                        layerActivations.push(activation);
                    }

                    activations.set(layer, layerActivations);
                }

                return activations;
            }

            calculatePatchingEffects(cleanActivations, corruptedActivations) {
                const effects = [];
                let significantComponents = 0;

                for (let layer = 0; layer < this.config.layers; layer++) {
                    const cleanLayer = cleanActivations.get(layer);
                    const corruptedLayer = corruptedActivations.get(layer);

                    const layerEffect = this.calculateKLDivergence(
                        this.flattenActivations(cleanLayer),
                        this.flattenActivations(corruptedLayer)
                    );

                    effects.push({
                        layer: layer,
                        effect: layerEffect,
                        significant: layerEffect > 0.1
                    });

                    if (layerEffect > 0.1) significantComponents++;
                }

                return { effects, significantComponents };
            }

            calculateLayerCausalEffect(tokens, baseline, layer) {
                // Simulate causal effect calculation
                let effect = Math.random() * 0.5;

                // Middle layers typically have higher causal effects
                const middleBoost = layer >= 4 && layer <= 8 ? 0.3 : 0;
                effect += middleBoost;

                // Add noise based on content
                const contentComplexity = tokens.filter(t => this.isContentWord(t)).length / tokens.length;
                effect += contentComplexity * 0.2;

                return Math.min(effect, 1.0);
            }

            discoverSAEFeatures(tokens) {
                const features = [];

                // Simulate discovered interpretable features
                const featureTypes = [
                    { description: 'Proper noun detection', sparsity: 0.95, category: 'syntax' },
                    { description: 'Pronoun binding patterns', sparsity: 0.88, category: 'syntax' },
                    { description: 'Sentiment polarity markers', sparsity: 0.92, category: 'semantics' },
                    { description: 'Causal relationship detection', sparsity: 0.89, category: 'reasoning' },
                    { description: 'Numerical quantity processing', sparsity: 0.94, category: 'content' },
                    { description: 'Temporal reference tracking', sparsity: 0.91, category: 'content' },
                    { description: 'Question formation patterns', sparsity: 0.96, category: 'syntax' },
                    { description: 'Negation scope detection', sparsity: 0.93, category: 'logic' }
                ];

                // Select relevant features based on input
                featureTypes.forEach(featureType => {
                    if (this.isFeatureRelevant(tokens, featureType)) {
                        features.push({
                            ...featureType,
                            activation: Math.random() * 0.8 + 0.2,
                            confidence: Math.random() * 0.4 + 0.6
                        });
                    }
                });

                return features;
            }

            calculateIntegratedGradients(tokens) {
                return tokens.map((token, i) => ({
                    token: token,
                    attribution: this.calculateTokenAttribution(token, i, tokens),
                    position: i
                }));
            }

            calculateTokenAttribution(token, position, allTokens) {
                let attribution = Math.random() * 0.5;

                // Content words have higher attribution
                if (this.isContentWord(token)) attribution += 0.4;

                // Function words have lower attribution
                if (this.isFunctionWord(token)) attribution *= 0.3;

                // Position effects
                if (position === allTokens.length - 1) attribution += 0.2; // Last token important for prediction

                // Syntactic importance
                if (this.isSyntacticallyImportant(token)) attribution += 0.3;

                return Math.min(attribution, 1.0);
            }

            ablateLayerNeurons(tokens, layer) {
                const results = [];
                const numNeurons = this.config.hiddenSize;

                // Simulate ablation of top neurons
                for (let neuron = 0; neuron < Math.min(numNeurons, 100); neuron++) {
                    const performanceDrop = this.calculateAblationEffect(tokens, layer, neuron);
                    results.push({
                        neuron: neuron,
                        effect: performanceDrop,
                        critical: performanceDrop > 0.1
                    });
                }

                return results.sort((a, b) => b.effect - a.effect);
            }

            calculateAblationEffect(tokens, layer, neuron) {
                let effect = Math.random() * 0.3;

                // Middle layers typically more important
                if (layer >= 4 && layer <= 8) effect += 0.2;

                // Some neurons are more critical
                if (neuron % 17 === 0) effect += 0.4; // Simulate sparse critical neurons

                return Math.min(effect, 1.0);
            }

            discoverComputationalCircuits(tokens) {
                const circuits = [
                    {
                        function: 'Indirect Object Identification',
                        components: [
                            { layer: 2, head: 5, role: 'subject_detection' },
                            { layer: 4, head: 8, role: 'verb_processing' },
                            { layer: 6, head: 2, role: 'object_binding' },
                            { layer: 8, head: 11, role: 'pronoun_resolution' }
                        ],
                        strength: 0.87,
                        confidence: 0.94
                    },
                    {
                        function: 'Factual Recall Circuit',
                        components: [
                            { layer: 1, head: 3, role: 'entity_recognition' },
                            { layer: 5, head: 7, role: 'knowledge_retrieval' },
                            { layer: 9, head: 1, role: 'fact_verification' },
                            { layer: 11, head: 6, role: 'output_formatting' }
                        ],
                        strength: 0.92,
                        confidence: 0.89
                    },
                    {
                        function: 'Syntactic Agreement',
                        components: [
                            { layer: 0, head: 9, role: 'pos_tagging' },
                            { layer: 3, head: 4, role: 'phrase_structure' },
                            { layer: 7, head: 10, role: 'agreement_checking' }
                        ],
                        strength: 0.78,
                        confidence: 0.82
                    }
                ];

                return circuits.filter(circuit => this.isCircuitActive(tokens, circuit));
            }

            // Visualization methods

            visualizeActivationPatching(patchingData, tokens) {
                const effects = patchingData.effects;

                const trace = {
                    x: effects.map(e => e.layer),
                    y: effects.map(e => e.effect),
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { color: '#58a6ff', width: 3 },
                    marker: {
                        size: 8,
                        color: effects.map(e => e.significant ? '#f85149' : '#58a6ff')
                    },
                    name: 'Patching Effect'
                };

                const layout = {
                    title: 'Activation Patching Results',
                    xaxis: { title: 'Layer', color: '#8b949e' },
                    yaxis: { title: 'KL Divergence', color: '#8b949e' },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc', size: 12 },
                    margin: { t: 40, l: 60, r: 20, b: 60 }
                };

                Plotly.newPlot('activationViz', [trace], layout, { responsive: true });
            }

            visualizeCausalEffects(patchingData) {
                const significantLayers = patchingData.effects.filter(e => e.significant);

                if (significantLayers.length === 0) {
                    document.getElementById('causalViz').innerHTML =
                        '<div style="text-align: center; padding: 50px; color: #8b949e;">No significant causal effects detected</div>';
                    return;
                }

                // Create network visualization of causal relationships
                const nodes = significantLayers.map(layer => ({
                    x: Math.random(),
                    y: Math.random(),
                    text: `L${layer.layer}`,
                    marker: {
                        size: 20 + layer.effect * 30,
                        color: layer.effect,
                        colorscale: 'Reds',
                        line: { width: 2, color: '#f0f6fc' }
                    }
                }));

                const trace = {
                    x: nodes.map(n => n.x),
                    y: nodes.map(n => n.y),
                    text: nodes.map(n => n.text),
                    mode: 'markers+text',
                    marker: nodes[0].marker,
                    type: 'scatter',
                    textposition: 'middle center'
                };

                const layout = {
                    title: 'Causal Circuit Map',
                    showlegend: false,
                    xaxis: { visible: false },
                    yaxis: { visible: false },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc' },
                    margin: { t: 40, l: 20, r: 20, b: 20 }
                };

                Plotly.newPlot('causalViz', [trace], layout, { responsive: true });
            }

            visualizeCausalTracing(causalEffects, tokens) {
                // Create 2D heatmap of causal effects
                const data = [causalEffects];

                const trace = {
                    z: data,
                    x: causalEffects.map((_, i) => `Layer ${i}`),
                    y: ['Causal Effect'],
                    type: 'heatmap',
                    colorscale: 'Viridis',
                    showscale: true,
                    hoverongaps: false
                };

                const layout = {
                    title: 'Layer-wise Causal Effects',
                    xaxis: { title: 'Layer', color: '#8b949e' },
                    yaxis: { title: '', color: '#8b949e' },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc', size: 11 },
                    margin: { t: 40, l: 60, r: 20, b: 60 }
                };

                Plotly.newPlot('activationViz', [trace], layout, { responsive: true });
            }

            visualizeSAEFeatures(features, tokens) {
                // Feature activation across tokens
                const traces = features.slice(0, 6).map((feature, idx) => ({
                    x: tokens,
                    y: tokens.map(() => this.gaussianRandom() * feature.activation),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: feature.description.split(' ')[0],
                    line: { color: `hsl(${idx * 60}, 70%, 60%)` }
                }));

                const layout = {
                    title: 'SAE Feature Activations',
                    xaxis: { title: 'Token Position', color: '#8b949e' },
                    yaxis: { title: 'Feature Activation', color: '#8b949e' },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc', size: 11 },
                    margin: { t: 40, l: 60, r: 20, b: 80 },
                    legend: { font: { size: 10 } }
                };

                Plotly.newPlot('attentionViz', [traces], layout, { responsive: true });

                // Feature sparsity visualization
                const sparsityTrace = {
                    x: features.map(f => f.description.split(' ')[0]),
                    y: features.map(f => f.sparsity),
                    type: 'bar',
                    marker: { color: '#56d364' },
                    name: 'Sparsity'
                };

                const sparsityLayout = {
                    title: 'Feature Sparsity Scores',
                    xaxis: { color: '#8b949e' },
                    yaxis: { title: 'Sparsity', color: '#8b949e' },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc', size: 11 },
                    margin: { t: 40, l: 60, r: 20, b: 100 }
                };

                Plotly.newPlot('causalViz', [sparsityTrace], sparsityLayout, { responsive: true });
            }

            visualizeGradientAttributions(attributions, tokens) {
                const trace = {
                    x: tokens,
                    y: attributions.map(a => a.attribution),
                    type: 'bar',
                    marker: {
                        color: attributions.map(a => a.attribution),
                        colorscale: 'Plasma',
                        showscale: true,
                        colorbar: { title: 'Attribution Score' }
                    }
                };

                const layout = {
                    title: 'Integrated Gradient Attributions',
                    xaxis: { title: 'Tokens', color: '#8b949e' },
                    yaxis: { title: 'Attribution Score', color: '#8b949e' },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc', size: 11 },
                    margin: { t: 40, l: 60, r: 20, b: 100 }
                };

                Plotly.newPlot('activationViz', [trace], layout, { responsive: true });
            }

            visualizeAblationResults(ablationResults, tokens) {
                const layerEffects = [];
                const layers = [];

                for (let [layer, results] of ablationResults) {
                    layers.push(`L${layer}`);
                    const avgEffect = results.slice(0, 10).reduce((sum, r) => sum + r.effect, 0) / 10;
                    layerEffects.push(avgEffect);
                }

                const trace = {
                    x: layers,
                    y: layerEffects,
                    type: 'bar',
                    marker: { color: '#ffa657' }
                };

                const layout = {
                    title: 'Neuron Ablation Effects by Layer',
                    xaxis: { title: 'Layer', color: '#8b949e' },
                    yaxis: { title: 'Performance Drop', color: '#8b949e' },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc', size: 11 },
                    margin: { t: 40, l: 60, r: 20, b: 60 }
                };

                Plotly.newPlot('circuitViz', [trace], layout, { responsive: true });
            }

            visualizeCircuits(circuits, tokens) {
                // Create network graph of circuit components
                const nodes = [];
                const edges = [];
                let nodeId = 0;

                circuits.forEach((circuit, circuitIdx) => {
                    const circuitNodes = [];

                    circuit.components.forEach((component, compIdx) => {
                        nodes.push({
                            id: nodeId,
                            x: Math.cos(compIdx * 2 * Math.PI / circuit.components.length) + circuitIdx * 3,
                            y: Math.sin(compIdx * 2 * Math.PI / circuit.components.length) + circuitIdx * 2,
                            text: `L${component.layer}H${component.head}`,
                            size: 15,
                            color: `hsl(${circuitIdx * 120}, 70%, 60%)`
                        });

                        circuitNodes.push(nodeId);
                        nodeId++;
                    });

                    // Connect components in circuit
                    for (let i = 0; i < circuitNodes.length - 1; i++) {
                        edges.push([circuitNodes[i], circuitNodes[i + 1]]);
                    }
                });

                // Plot nodes
                const nodeTrace = {
                    x: nodes.map(n => n.x),
                    y: nodes.map(n => n.y),
                    text: nodes.map(n => n.text),
                    mode: 'markers+text',
                    type: 'scatter',
                    marker: {
                        size: nodes.map(n => n.size),
                        color: nodes.map(n => n.color),
                        line: { width: 2, color: '#f0f6fc' }
                    },
                    textposition: 'middle center'
                };

                // Plot edges
                const edgeTraces = edges.map(edge => ({
                    x: [nodes[edge[0]].x, nodes[edge[1]].x],
                    y: [nodes[edge[0]].y, nodes[edge[1]].y],
                    mode: 'lines',
                    type: 'scatter',
                    line: { color: '#30363d', width: 2 },
                    showlegend: false,
                    hoverinfo: 'skip'
                }));

                const layout = {
                    title: 'Discovered Computational Circuits',
                    showlegend: false,
                    xaxis: { visible: false },
                    yaxis: { visible: false },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc' },
                    margin: { t: 40, l: 20, r: 20, b: 20 }
                };

                Plotly.newPlot('circuitViz', [...edgeTraces, nodeTrace], layout, { responsive: true });
            }

            updateVisualizationsForLayer(layerIndex) {
                this.log(`Analyzing layer ${layerIndex} activations...`, 'info');

                if (!this.tokens.length) {
                    this.log('No tokens available. Run an analysis first.', 'warning');
                    return;
                }

                // Generate attention head analysis for this layer
                this.visualizeAttentionHeads(layerIndex);
            }

            visualizeAttentionHeads(layerIndex) {
                const heads = [];
                const tokens = this.tokens;

                for (let head = 0; head < this.config.heads; head++) {
                    const headData = this.generateAttentionHeadData(layerIndex, head, tokens);
                    heads.push(headData);
                }

                // Create attention pattern heatmap
                const attentionMatrix = this.generateAttentionMatrix(tokens, layerIndex);

                const trace = {
                    z: attentionMatrix,
                    x: tokens,
                    y: tokens,
                    type: 'heatmap',
                    colorscale: 'Blues',
                    showscale: true
                };

                const layout = {
                    title: `Layer ${layerIndex} Attention Patterns`,
                    xaxis: { title: 'Key Tokens', color: '#8b949e' },
                    yaxis: { title: 'Query Tokens', color: '#8b949e' },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc', size: 10 },
                    margin: { t: 40, l: 80, r: 20, b: 80 }
                };

                Plotly.newPlot('attentionViz', [trace], layout, { responsive: true });
            }

            generateAttentionMatrix(tokens, layer) {
                const matrix = [];

                for (let i = 0; i < tokens.length; i++) {
                    const row = [];
                    for (let j = 0; j < tokens.length; j++) {
                        let attention = 0.1 + Math.random() * 0.1;

                        // Self-attention
                        if (i === j) attention += 0.3;

                        // Local attention (adjacent tokens)
                        if (Math.abs(i - j) === 1) attention += 0.2;

                        // Syntactic dependencies
                        if (this.hasSyntacticDependency(tokens[i], tokens[j])) {
                            attention += 0.4;
                        }

                        // Long-range dependencies for deeper layers
                        if (layer > 6 && Math.abs(i - j) > 3) {
                            attention += 0.15;
                        }

                        row.push(Math.min(attention, 1.0));
                    }
                    matrix.push(row);
                }

                return matrix;
            }

            // Utility methods

            updateStatus(status, message) {
                const indicator = document.getElementById('statusIndicator');
                const text = document.getElementById('statusText');

                indicator.className = `status-indicator ${status}`;
                text.textContent = message;
            }

            updateProgress(percent) {
                document.getElementById('progressFill').style.width = `${percent}%`;
            }

            log(message, type = 'info') {
                const console = document.getElementById('console');
                const line = document.createElement('div');
                line.className = `console-line ${type}`;
                line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                console.appendChild(line);
                console.scrollTop = console.scrollHeight;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            gaussianRandom() {
                // Box-Muller transform for gaussian random numbers
                if (this.spare !== undefined) {
                    const tmp = this.spare;
                    delete this.spare;
                    return tmp;
                }

                const u = Math.random();
                const v = Math.random();
                const mag = 0.5 * Math.sqrt(-2 * Math.log(u));
                this.spare = mag * Math.cos(2 * Math.PI * v);
                return mag * Math.sin(2 * Math.PI * v);
            }

            isContentWord(token) {
                const functionWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'];
                return !functionWords.includes(token.toLowerCase()) && token.length > 2;
            }

            isFunctionWord(token) {
                const functionWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'];
                return functionWords.includes(token.toLowerCase());
            }

            isSyntacticallyImportant(token) {
                const importantPOS = ['verb', 'noun', 'adjective'];
                // Simplified: assume longer words are more syntactically important
                return token.length > 4 && !this.isFunctionWord(token);
            }

            hasSyntacticDependency(token1, token2) {
                // Simplified syntactic dependency detection
                const patterns = [
                    [/\w+ed$/, /\w+/], // Past tense verb to object
                    [/\w+ing$/, /\w+/], // Present participle to object
                    [/^[A-Z]/, /\w+/], // Proper noun relationships
                ];

                return patterns.some(([pattern1, pattern2]) =>
                    pattern1.test(token1) && pattern2.test(token2)
                );
            }

            calculateKLDivergence(p, q) {
                // Simplified KL divergence calculation
                let kl = 0;
                for (let i = 0; i < Math.min(p.length, q.length); i++) {
                    if (p[i] > 0 && q[i] > 0) {
                        kl += p[i] * Math.log(p[i] / q[i]);
                    }
                }
                return Math.abs(kl) / Math.min(p.length, q.length);
            }

            flattenActivations(layerActivations) {
                return layerActivations.flat();
            }

            isFeatureRelevant(tokens, featureType) {
                const text = tokens.join(' ');

                switch (featureType.category) {
                    case 'syntax':
                        return /[A-Z]/.test(text) || /\?/.test(text);
                    case 'semantics':
                        return /\b(good|bad|love|hate|happy|sad)\b/.test(text);
                    case 'reasoning':
                        return /\b(because|therefore|since|so)\b/.test(text);
                    case 'content':
                        return /\d+/.test(text) || /\b(when|where|what|who)\b/.test(text);
                    case 'logic':
                        return /\b(not|never|no|none)\b/.test(text);
                    default:
                        return Math.random() > 0.5;
                }
            }

            isCircuitActive(tokens, circuit) {
                const text = tokens.join(' ').toLowerCase();

                switch (circuit.function) {
                    case 'Indirect Object Identification':
                        return /\b(he|she|they|it)\b/.test(text) && /\b(his|her|their|its)\b/.test(text);
                    case 'Factual Recall Circuit':
                        return /[A-Z]/.test(tokens.join(' ')) && tokens.some(t => t.length > 5);
                    case 'Syntactic Agreement':
                        return tokens.length > 3 && /\b(is|are|was|were)\b/.test(text);
                    default:
                        return Math.random() > 0.3;
                }
            }

            generateRandomTokenSequence(length) {
                const randomTokens = ['apple', 'tree', 'blue', 'run', 'quickly', 'the', 'and', 'but'];
                return Array(length).fill().map(() =>
                    randomTokens[Math.floor(Math.random() * randomTokens.length)]
                );
            }

            generateAttentionHeadData(layer, head, tokens) {
                return {
                    layer: layer,
                    head: head,
                    specialization: this.determineHeadSpecialization(layer, head),
                    entropy: Math.random() * 3 + 1,
                    maxAttention: Math.random() * 0.8 + 0.2
                };
            }

            determineHeadSpecialization(layer, head) {
                const specializations = [
                    'Previous token attention',
                    'Positional patterns',
                    'Syntactic dependencies',
                    'Long-range context',
                    'Entity coreference',
                    'Causal relationships',
                    'Semantic similarity',
                    'Factual recall',
                    'Question answering',
                    'Negation handling'
                ];

                // Assign based on layer and head for consistency
                const index = (layer * this.config.heads + head) % specializations.length;
                return specializations[index];
            }
        }

        // Global research environment
        const interpreter = new MechanisticInterpreter();

        // Main functions
        async function initializeResearchEnvironment() {
            await interpreter.initialize();
        }

        async function runMechanisticAnalysis() {
            await interpreter.runMechanisticAnalysis();
        }

        function switchTab(tabName) {
            // Remove active from all tabs
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

            // Activate clicked tab
            event.target.classList.add('active');

            // Update analysis method based on tab
            const methodMap = {
                'activation': 'activation_patching',
                'attention': 'gradient_attribution',
                'circuits': 'circuit_discovery',
                'ablation': 'neuron_ablation'
            };

            if (methodMap[tabName]) {
                document.getElementById('researchMethod').value = methodMap[tabName];
            }
        }

        function exportResults() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const results = {
                timestamp: timestamp,
                model: document.getElementById('modelVariant').value,
                method: document.getElementById('researchMethod').value,
                inputText: document.getElementById('inputText').value,
                config: interpreter.config,
                activations: Array.from(interpreter.activations.entries()),
                circuits: Array.from(interpreter.circuits.entries()),
                interventions: Array.from(interpreter.interventionResults.entries())
            };

            const dataStr = JSON.stringify(results, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `gpt2_interpretability_${timestamp}.json`;
            link.click();

            interpreter.log('Results exported successfully', 'success');
        }

        function loadPreset() {
            const presets = [
                {
                    name: 'Pronoun Resolution Study',
                    input: 'When John and Mary went to the store, they bought apples. John paid for them.',
                    comparison: 'When John and Mary went to the store, they bought apples. Mary paid for them.',
                    method: 'activation_patching'
                },
                {
                    name: 'Factual Recall Circuit',
                    input: 'The Eiffel Tower is located in Paris, France.',
                    comparison: 'The Statue of Liberty is located in New York, USA.',
                    method: 'circuit_discovery'
                },
                {
                    name: 'Negation Processing',
                    input: 'I do not like chocolate ice cream.',
                    comparison: 'I do like chocolate ice cream.',
                    method: 'sae_analysis'
                },
                {
                    name: 'Question Formation',
                    input: 'What is the capital of France?',
                    comparison: 'The capital of France is Paris.',
                    method: 'gradient_attribution'
                }
            ];

            const preset = presets[Math.floor(Math.random() * presets.length)];

            document.getElementById('inputText').value = preset.input;
            document.getElementById('comparisonText').value = preset.comparison;
            document.getElementById('researchMethod').value = preset.method;

            interpreter.log(`Loaded preset: ${preset.name}`, 'info');
        }

        // Advanced research methods
        async function runAdvancedCircuitAnalysis() {
            interpreter.log('Running advanced circuit discovery with path patching...', 'info');

            const tokens = interpreter.tokenize(document.getElementById('inputText').value);

            // Simulate path patching experiment
            interpreter.log('Testing direct vs indirect paths...', 'info');
            await interpreter.delay(1000);

            const pathResults = {
                directPath: Math.random() * 0.8 + 0.1,
                indirectPath: Math.random() * 0.6 + 0.1,
                totalEffect: Math.random() * 0.9 + 0.1
            };

            interpreter.log(`Direct path contribution: ${(pathResults.directPath * 100).toFixed(1)}%`, 'success');
            interpreter.log(`Indirect path contribution: ${(pathResults.indirectPath * 100).toFixed(1)}%`, 'success');

            return pathResults;
        }

        async function runInterventionExperiment() {
            interpreter.log('Running causal intervention experiment...', 'info');

            const interventions = [
                { layer: 3, component: 'attention_head_5', effect: 'knockout' },
                { layer: 7, component: 'mlp_neuron_234', effect: 'amplify' },
                { layer: 9, component: 'attention_head_2', effect: 'clamp' }
            ];

            for (const intervention of interventions) {
                interpreter.log(`Applying ${intervention.effect} to L${intervention.layer} ${intervention.component}...`, 'info');
                await interpreter.delay(300);

                const behaviorChange = Math.random() * 0.5;
                interpreter.log(`Behavior change: ${(behaviorChange * 100).toFixed(2)}%`, 'info');
            }

            interpreter.log('Intervention experiment complete', 'success');
        }

        // Initialize on page load
        window.onload = function () {
            interpreter.log('Mechanistic interpretability research platform loaded', 'info');
            interpreter.log('Initialize model to begin experiments', 'info');

            // Add advanced research controls
            const advancedControls = document.createElement('div');
            advancedControls.innerHTML = `
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-primary);">
                    <h3 style="color: var(--accent-purple); margin-bottom: 15px; font-size: 1rem;">Advanced Methods</h3>
                    <button class="btn secondary" onclick="runAdvancedCircuitAnalysis()">🔬 Path Patching</button>
                    <button class="btn secondary" onclick="runInterventionExperiment()">⚡ Causal Intervention</button>
                    <button class="btn secondary" onclick="runFeatureVisualization()">🎯 Feature Visualization</button>
                    <button class="btn secondary" onclick="runProbeStudy()">📊 Linear Probe Study</button>
                </div>
            `;

            document.querySelector('.sidebar').appendChild(advancedControls);

            // Add research notes section
            const notesSection = document.createElement('div');
            notesSection.innerHTML = `
                <div class="code-block" style="margin-top: 20px;">
                    <div style="color: var(--accent-green); margin-bottom: 10px;">Research Notes:</div>
                    <div style="font-size: 0.7rem; line-height: 1.4;">
                    • Activation patching: Tests causal importance of components<br>
                    • SAE analysis: Discovers monosemantic features<br>
                    • Circuit discovery: Maps computational subgraphs<br>
                    • Gradient attribution: Shows input importance<br>
                    • Ablation studies: Tests necessity of components
                    </div>
                </div>
            `;

            document.querySelector('.sidebar').appendChild(notesSection);
        };

        // Additional advanced research functions

        async function runFeatureVisualization() {
            interpreter.log('Generating feature visualizations...', 'info');

            await interpreter.delay(800);

            // Simulate feature visualization like those from Clarity/OpenAI
            const features = [
                { name: 'Subject-Verb Agreement', layer: 5, neuron: 234, strength: 0.89 },
                { name: 'Factual Recall', layer: 8, neuron: 456, strength: 0.94 },
                { name: 'Sentiment Detection', layer: 6, neuron: 123, strength: 0.76 },
                { name: 'Causal Reasoning', layer: 10, neuron: 789, strength: 0.83 }
            ];

            features.forEach(feature => {
                interpreter.log(`Found feature: ${feature.name} in L${feature.layer}N${feature.neuron} (strength: ${feature.strength})`, 'success');
            });

            // Visualize feature activations
            const trace = {
                x: features.map(f => `L${f.layer}N${f.neuron}`),
                y: features.map(f => f.strength),
                text: features.map(f => f.name),
                type: 'bar',
                marker: {
                    color: features.map(f => f.strength),
                    colorscale: 'Viridis'
                }
            };

            const layout = {
                title: 'Discovered Interpretable Features',
                xaxis: { title: 'Neuron Location', color: '#8b949e' },
                yaxis: { title: 'Feature Strength', color: '#8b949e' },
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent',
                font: { color: '#f0f6fc', size: 11 },
                margin: { t: 40, l: 60, r: 20, b: 100 }
            };

            Plotly.newPlot('circuitViz', [trace], layout, { responsive: true });
        }

        async function runProbeStudy() {
            interpreter.log('Running linear probe study on model representations...', 'info');

            const tasks = [
                { name: 'POS Tagging', accuracy: 0.89 + Math.random() * 0.1 },
                { name: 'Dependency Parsing', accuracy: 0.76 + Math.random() * 0.1 },
                { name: 'Named Entity Recognition', accuracy: 0.84 + Math.random() * 0.1 },
                { name: 'Sentiment Classification', accuracy: 0.91 + Math.random() * 0.08 },
                { name: 'Factual Knowledge', accuracy: 0.67 + Math.random() * 0.15 }
            ];

            const layerResults = [];

            for (let layer = 0; layer < interpreter.config.layers; layer++) {
                await interpreter.delay(100);

                const layerAccuracies = tasks.map(task => {
                    let acc = task.accuracy;

                    // Middle layers typically perform better
                    if (layer >= 4 && layer <= 8) acc += 0.05;

                    // Add layer-specific noise
                    acc += (Math.random() - 0.5) * 0.1;

                    return Math.max(0, Math.min(1, acc));
                });

                layerResults.push(layerAccuracies);
            }

            // Visualize probe results
            const traces = tasks.map((task, taskIdx) => ({
                x: Array.from({ length: interpreter.config.layers }, (_, i) => i),
                y: layerResults.map(layer => layer[taskIdx]),
                type: 'scatter',
                mode: 'lines+markers',
                name: task.name,
                line: { width: 2 }
            }));

            const layout = {
                title: 'Linear Probe Accuracy Across Layers',
                xaxis: { title: 'Layer', color: '#8b949e' },
                yaxis: { title: 'Probe Accuracy', color: '#8b949e' },
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent',
                font: { color: '#f0f6fc', size: 11 },
                margin: { t: 40, l: 60, r: 20, b: 60 },
                legend: { font: { size: 10 } }
            };

            Plotly.newPlot('activationViz', traces, layout, { responsive: true });

            interpreter.log('Linear probe study complete', 'success');
            tasks.forEach(task => {
                const avgAcc = layerResults.reduce((sum, layer) => sum + layer[tasks.indexOf(task)], 0) / interpreter.config.layers;
                interpreter.log(`${task.name}: Average accuracy ${(avgAcc * 100).toFixed(1)}%`, 'info');
            });
        }

        // Research utility functions

        function generateActivationHeatmap(layer, tokens) {
            // Generate realistic activation patterns for visualization
            const numNeurons = 50; // Subset for visualization
            const activationMatrix = [];

            for (let neuron = 0; neuron < numNeurons; neuron++) {
                const neuronActivations = [];

                for (let pos = 0; pos < tokens.length; pos++) {
                    let activation = interpreter.gaussianRandom() * 0.3 + 0.5;

                    // Add realistic patterns
                    if (interpreter.isContentWord(tokens[pos])) {
                        activation += 0.3;
                    }

                    if (layer > 6 && pos > tokens.length * 0.7) {
                        activation += 0.2; // Later positions in deeper layers
                    }

                    neuronActivations.push(Math.max(0, Math.min(1, activation)));
                }

                activationMatrix.push(neuronActivations);
            }

            const trace = {
                z: activationMatrix,
                x: tokens,
                y: Array.from({ length: numNeurons }, (_, i) => `N${i}`),
                type: 'heatmap',
                colorscale: 'Viridis',
                showscale: true
            };

            const layout = {
                title: `Layer ${layer} Neuron Activations`,
                xaxis: { title: 'Tokens', color: '#8b949e' },
                yaxis: { title: 'Neurons', color: '#8b949e' },
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent',
                font: { color: '#f0f6fc', size: 10 },
                margin: { t: 40, l: 60, r: 20, b: 80 }
            };

            Plotly.newPlot('activationViz', [trace], layout, { responsive: true });
        }

        function analyzeAttentionHead(layer, head) {
            interpreter.log(`Analyzing attention head L${layer}H${head}...`, 'info');

            const specialization = interpreter.determineHeadSpecialization(layer, head);
            const entropy = Math.random() * 3 + 1;
            const maxAttention = Math.random() * 0.8 + 0.2;

            interpreter.log(`Specialization: ${specialization}`, 'info');
            interpreter.log(`Attention entropy: ${entropy.toFixed(3)}`, 'info');
            interpreter.log(`Max attention weight: ${maxAttention.toFixed(3)}`, 'info');

            // Generate attention pattern for this head
            const tokens = interpreter.tokens;
            if (tokens.length > 0) {
                const attentionPattern = interpreter.generateAttentionMatrix(tokens, layer);

                // Focus on this specific head (simulate head-specific pattern)
                const headPattern = attentionPattern.map(row =>
                    row.map(val => val * (Math.random() * 0.5 + 0.5))
                );

                const trace = {
                    z: headPattern,
                    x: tokens,
                    y: tokens,
                    type: 'heatmap',
                    colorscale: 'Blues',
                    showscale: true
                };

                const layout = {
                    title: `L${layer}H${head}: ${specialization}`,
                    xaxis: { title: 'Key Tokens', color: '#8b949e' },
                    yaxis: { title: 'Query Tokens', color: '#8b949e' },
                    plot_bgcolor: 'transparent',
                    paper_bgcolor: 'transparent',
                    font: { color: '#f0f6fc', size: 10 },
                    margin: { t: 40, l: 80, r: 20, b: 80 }
                };

                Plotly.newPlot('attentionViz', [trace], layout, { responsive: true });
            }
        }

        // Research-specific event handlers

        document.addEventListener('keydown', function (e) {
            // Keyboard shortcuts for researchers
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'Enter':
                        e.preventDefault();
                        if (interpreter.isInitialized) runMechanisticAnalysis();
                        break;
                    case 's':
                        e.preventDefault();
                        exportResults();
                        break;
                    case 'l':
                        e.preventDefault();
                        loadPreset();
                        break;
                }
            }
        });

        // Add real-time parameter updates
        document.getElementById('layerRange').addEventListener('input', function (e) {
            const range = e.target.value;
            interpreter.log(`Layer range updated: ${range}`, 'info');
        });

        document.getElementById('threshold').addEventListener('input', function (e) {
            const threshold = e.target.value;
            interpreter.log(`Analysis threshold: ${threshold}`, 'info');
        });

        // Simulate real research scenarios
        function simulateResearchScenario(scenario) {
            const scenarios = {
                'induction_heads': {
                    description: 'Investigating induction head formation in GPT-2',
                    input: 'A B A B A B A',
                    expectedPattern: 'Strong attention from second A to first B'
                },
                'factual_editing': {
                    description: 'Locating factual knowledge storage',
                    input: 'The Space Needle is in Seattle',
                    intervention: 'Patch activations to change factual recall'
                },
                'composition': {
                    description: 'How model composes multiple facts',
                    input: 'John, who lives in Paris, speaks French',
                    analysis: 'Track information flow through layers'
                }
            };

            const config = scenarios[scenario];
            if (config) {
                document.getElementById('inputText').value = config.input;
                interpreter.log(`Loaded scenario: ${config.description}`, 'info');

                if (config.expectedPattern) {
                    interpreter.log(`Expected: ${config.expectedPattern}`, 'info');
                }
            }
        }

        // Add scenario buttons to sidebar
        setTimeout(() => {
            const scenarioSection = document.createElement('div');
            scenarioSection.innerHTML = `
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-primary);">
                    <h3 style="color: var(--accent-orange); margin-bottom: 15px; font-size: 1rem;">Research Scenarios</h3>
                    <button class="btn secondary" onclick="simulateResearchScenario('induction_heads')">🔄 Induction Heads</button>
                    <button class="btn secondary" onclick="simulateResearchScenario('factual_editing')">📝 Factual Editing</button>
                    <button class="btn secondary" onclick="simulateResearchScenario('composition')">🧩 Composition</button>
                </div>
            `;

            document.querySelector('.sidebar').appendChild(scenarioSection);
        }, 1000);
    </script>
</body>

</html>